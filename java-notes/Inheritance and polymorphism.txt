Inheritance and Polymorphism

To define a child class that inherits from a parent class, we use the keyword 'extends'

Inheriting the constructor:
- the super() method acts like the parent constructor inside the child class constructor. it is used to call the constructor and methods 
of a superclass
- if you're writing a constructor of a child class and don't explicitly make a call to a constructor from a parent class using 'super', it's important to remember that Java will automatically (and secretly) call super() as the first line of your child class constructor.

Parent Class Aspect Modifiers:
- a child class can't inherit a private member from the parent class HOWEVER there is an access modifier that makes a member available to the child class which is called 'protected'. protected makes a parent class member accessible to its child classes and files in the package it's contained in and private.

- another way to establish how child classes can interact with inherited parent class members is by using the 'final' keyword. When we add the final before a parent class method's access modifier, we disallow any child class from changing that method. this is HELPFUL in limiting bugs that might occur from modifying a particula method.

Introducing polymorphism:
- Polymorphism allows a child class to share the information and behaviour of its parent class while also incorporating its own functionality.

- main advantages of polymorphic programmings:
	* simpligying syntax
	* reducing cognitive overload for developers
	
For example, the built-in operator + can be used for both doubles and ints. To the computer, the + means something like addDouble() for one and addInt() for the other, but the creators of Java (and of other languages) didn’t want to burden us as developers with recalling each individual method.
	
https://www.codecademy.com/courses/learn-java/lessons/java-inheritance-and-polymorphism/exercises/introducing-polymorphism

- though you can't use a genericc parent class instance where a child class instance is required

Method Overriding:
- let's say we want a child class to inherit a method from a parent class with the method name but want to tweak the method a lil bit and make it do something else, we use "override".

e.g. Let's say we have a BankAccount class that let's us print current balance. We want a Savings account class that inherits the functionality of a BankAccount but with a modified printBalance() method


class BankAccount {

protected double balance;

public void printBalance(){

System.out.println("your account balance is: " + balance);


}

class SavingsAccount extends BankAccount {

@Override

public void printBalance(){

System.out.println("your savings account balance is: " + balance);

}
}

Notice that in order to properly override the method, we needed to have the same
- method name
- return type
- number and type of parameters


Using a child class as its parent class (...polymorphism):
- to do this, we have to instantiate a child class object as a member of the parent class.

	parentClass childClassObject = new childClass();
	
e.g. to instantiate a SavingsAccount object as a BankAccount:

BankAccount jadensAccount = new SavingsAccount(500);

now we can use jadensAccount as if it were an instance of BankAccount in any situation where a BankAccount would be expected. This would also be true if jadensAccount were instantiated as a SavingsAccount but using the explicit child as parent syntax is most helpful when we want to declare objects in bulk


Child Classes in Arrays and ArrayLists
- did you know we could create an Array / ArrayList of instances of different classes that share a parent class together?

For example, let’s say we have a Monster parent class with a few child classes: Vampire, Werewolf, and Zombie. We can set up an array with instances of each:

		
		Monster dracula, wolfman, zombie1;
		 
		dracula = new Vampire();
		wolfman = new Werewolf();
		zombie1 = new Zombie();
		 
		Monster[] monsters = {dracula, wolfman, zombie1};
		
We can even iterate through the list of items — regardless of subclass — and perform the same action with each item:

		for (Monster monster : monsters) {
		 
		  monster.attack();
		 
		}
		
In the code above, we were able to call attack() on each monster in monsters despite the fact that, in the for-each loop, monster is declared as the parent class type Monster.


Child classes in method parameters:

https://www.codecademy.com/courses/learn-java/lessons/java-inheritance-and-polymorphism/exercises/child-classes-in-method-parameters

class NoodleRestaurant {
  String name;

  public NoodleRestaurant(String customerName){
    name = customerName;
  }

  public void order(Noodle noodle) {
    System.out.println(noodle.getCookPrep());
    System.out.println("Order for " + name + " is ready.");
  }//method

  public static void main(String[] args) {
    Noodle ramen, pho;
    ramen = new Ramen();
    pho = new Pho(); //pho object of child class Pho
        
    NoodleRestaurant customer1 = new NoodleRestaurant("Sagirah");
    NoodleRestaurant customer2 = new NoodleRestaurant("Maritza");

    // Add your code here
customer1.order(pho);
customer2.order(ramen);



  }
}








